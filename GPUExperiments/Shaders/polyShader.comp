#version 430

//layout (local_size_x = 9, local_size_y = 4) in; 
layout (local_size_x = 1, local_size_y = 1) in; 

struct PolyVertex {
   vec4  location; 
   vec4  color; 
};

layout (std430, binding = 1) buffer VertexBuffer {
   PolyVertex verts [];
};

struct Store {
   int  storeId;
   int  count; 
   int  seriesType;
   int  seriesIndex;
   int  samplerType; 
};

struct Composite {
   int  id;
   int  parentId;
   int  childIdsIndex;
   int  elementCount; 
   int  nestedElementCounts; 
   int  elementCapacity; 
   Store props[32];
};

layout(std430, binding = 2) buffer FloatSeriesBuffer {
	int[256] floatSeriesOffsets;
	int[256] floatSeriesLengths;
	float[] floatSeriesValues;
};
layout(std430, binding = 3) buffer IntSeriesBuffer {
	int[256] intSeriesOffsets;
	int[256] intSeriesLengths;
	int[] intSeriesValues;
};

 vec4 gridSample(ivec4 rowCol, uint index)
 {
	float x = (index % rowCol.x) / (rowCol.x - 1.0f);
	float y = floor(index / rowCol.x) / (rowCol.y - 1.0f);
	return vec4(x,y,1,1);
 }
 vec4 hexGridSample(ivec4 rowCol, uint index)
 {
	uint yIndex = uint(floor(index / rowCol.x));
	float y = yIndex / (rowCol.y - 1.0f);
	float oddRow = mod(yIndex, 2 ) == 0 ? 0 : 1.0;
	float xStep = 1.0 / (rowCol.x - 1.0f);
	float x = (index % rowCol.x) * xStep + oddRow * xStep / 2.0;
	return vec4(x,y,1,1);
 }
 const float PI = 3.1415926535897932384626433832795;
 const float PIx2 = PI * 2.0f;

 void main() 
 {
	uint index = uint(dot(gl_GlobalInvocationID, vec3(gl_WorkGroupSize.yz, 1)));
	
	ivec4 rowCol = ivec4(22, 22, 1, 1);
	int capacity = rowCol.x * rowCol.y * rowCol.z * rowCol.w;
	vec2 bl = vec2(-0.8, -0.8);
	vec2 tr = vec2(0.8, 0.8);
	vec2 radius = vec2(0.04f, 0.04f);
	int sideCount = 6;

	uint startIndex = index * (sideCount * 3);
//	float offsetX = mix(xRange.x, xRange.y, (index % rowCol.x) / (rowCol.x - 1.0f));
//	float offsetY = mix(yRange.x, yRange.y, floor(index / rowCol.x) / (rowCol.y - 1.0f));
	vec4 offset4 = hexGridSample(rowCol, index);
	vec2 offset = mix(bl, tr, offset4.xy);
	float offsetX = offset.x;
	float offsetY = offset.y;

	float pt = float(sideCount - 1) / float(sideCount);
	for(int i = 0 ; i < sideCount; i++)
	{
		float t = i / float(sideCount);
		float px = sin(pt * PIx2) * radius.x;
		float py = cos(pt * PIx2) * radius.y;
		float xp = sin(t  * PIx2) * radius.x;
		float yp = cos(t  * PIx2) * radius.y;
		uint idx = startIndex + i * 3;
		verts[idx + 0].location = vec4(offsetX, offsetY, 0, 1.0);
		verts[idx + 1].location = vec4(xp + offsetX, yp + offsetY, 0, 1.0);
		verts[idx + 2].location = vec4(px + offsetX, py + offsetY, 0, 1.0);

		verts[idx + 0].color = vec4(1.0, 0.8, 0.3, 1.0);
		verts[idx + 1].color = vec4(0.5, 0.2, 0.0, 1.0);
		verts[idx + 2].color = vec4(0.5, 0.2, 0.0, 1.0);
		pt = t;
	}

//	verts[startIndex + 0].location = vec4(-0.05f + offsetX, -0.05f + offsetY, 0, 1.0);
//	verts[startIndex + 1].location = vec4(+0.05f + offsetX, -0.05f + offsetY, 0, 1.0);
//	verts[startIndex + 2].location = vec4(+0.00f + offsetX, +0.05f + offsetY, 0, 1.0);
											    
//	verts[startIndex + 0].color = vec4(1.0, 0.8, 0.3, 1.0);
//	verts[startIndex + 1].color = vec4(offsetX + 0.5, 0.1, 0.0, 1.0);
//	verts[startIndex + 2].color = vec4(0.1, 0.4, offsetY + 0.5, 1.0);
 }