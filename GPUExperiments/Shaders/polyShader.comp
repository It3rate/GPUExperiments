#version 430

//layout (local_size_x = 9, local_size_y = 4) in; 
layout (local_size_x = 1, local_size_y = 1) in; 

struct PolyVertex {
   vec4  location; 
   vec4  color; 
};

layout (std430, binding = 1) buffer VertexBuffer {
   PolyVertex verts [];
};

layout(std430, binding = 2) buffer ProgramState {
   int currentTicks;
   int previousTicks;
   int totalElementCount;
   float activeElementIds[];
};

layout(std430, binding = 3) buffer FloatSeriesBuffer {
	uint[256] floatSeriesOffsets;
	uint[256] floatSeriesLengths;
	float floatSeriesValues[];
};
layout(std430, binding = 4) buffer IntSeriesBuffer {
	uint[256] intSeriesOffsets;
	uint[256] intSeriesLengths;
	int intSeriesValues[];
};

struct Store {
   uint storeId;
   uint seriesType;
   uint seriesIndex;
   uint samplerIndex; 
};

struct Sampler {
   uint type;
   uint capacity;
   uint swizzleMap;
   uint neighborCount;
   vec4 strides;
   vec4 params0;
};

struct Composite {
   uint id;
   uint parentId;
   uint childIdsIndex;
   uint elementCount; 
   uint nestedElementCounts; 
   uint elementCapacity; 
   uint propTypes[32];
   Store propStores[32];
};


 vec4 gridSample(ivec4 rowCol, uint index)
 {
	float x = (index % rowCol.x) / (rowCol.x - 1.0f);
	float y = floor(index / rowCol.x) / (rowCol.y - 1.0f);
	return vec4(x,y,1,1);
 }
 vec4 hexGridSample(ivec4 rowCol, uint index)
 {
	uint yIndex = uint(floor(index / rowCol.x));
	float y = yIndex / (rowCol.y - 1.0f);
	float oddRow = mod(yIndex, 2 ) == 0 ? 0 : 1.0;
	float xStep = 1.0 / (rowCol.x - 1.0f);
	float x = (index % rowCol.x) * xStep + oddRow * xStep / 2.0;
	return vec4(x,y,1,1);
 }
 const float PI = 3.1415926535897932384626433832795;
 const float PIx2 = PI * 2.0f;    
 const  float floatSeries[16] = float[] (0.3, 0.1, 0.0, 1.0,    0.1, 0.5, 1.0, 1.0,    1.0, 1.0, 0.0, 1.0,   1.0, 0.0, 0.1, 1.0);

 vec4 getMixWrapped4(int start, int len, float t)
 {
	vec4 result = vec4(0);
	int size = 4;
	float slotCount = float(len) - 1.0f;
	float indexf;
	float rem = modf(t * slotCount, indexf);
	int index = int(mod(indexf, slotCount + 0.01f));
	int startIndex = (index + start) * size;
	int endIndex = (index >= slotCount) ? startIndex : startIndex + size;
	for(int i = 0; i < size; i++)
	{
		result[i] = mix(floatSeries[startIndex + i], floatSeries[endIndex + i], rem);
	}
	return result; 
 }

 void main() 
 {
	uint index = uint(dot(gl_GlobalInvocationID, vec3(gl_WorkGroupSize.yz, 1)));
	
	ivec4 rowCol = ivec4(22, 22, 1, 1);
	int capacity = rowCol.x * rowCol.y * rowCol.z * rowCol.w;
	vec4 box = vec4(-0.8, -0.8, 0.8, 0.8);
	vec2 radius = vec2(0.04f, 0.04f);
	int sideCount = 6;
	vec4 cols[3] = {vec4(1.0, 0.0, 0.1, 1.0), vec4(0.1, 0.5, 1.0, 1.0), vec4(1.0, 1.0, 0.0, 1.0)};

	uint startIndex = index * (sideCount * 3);
	vec4 offset4 = hexGridSample(rowCol, index);
	vec2 offset = mix(box.xy, box.zw, offset4.xy);

	float pt = float(sideCount - 1) / float(sideCount);
	float px = sin(pt * PIx2) * radius.x;
	float py = cos(pt * PIx2) * radius.y;
	for(int i = 0 ; i < sideCount; i++)
	{
		float t = i / float(sideCount);
		float x = sin(t * PIx2) * radius.x;
		float y = cos(t * PIx2) * radius.y;
		uint idx = startIndex + i * 3;
		verts[idx + 0].location = vec4(offset.x, offset.y, 0, 1.0);
		verts[idx + 1].location = vec4(x + offset.x, y + offset.y, 0, 1.0);
		verts[idx + 2].location = vec4(px + offset.x, py + offset.y, 0, 1.0);

		float indexT = index / float(capacity);
		vec4 col = getMixWrapped4(0, 3, indexT);
		vec4 outColor = getMixWrapped4(1, 3, 1.0f - indexT);
		//vec4 col = mix(cols[0], cols[1], indexT);
		//vec4 outColor = mix(cols[1], cols[0], indexT);
		float time = abs(mod(currentTicks, 1000) / 500.0f - 1.0f);
		verts[idx + 0].color = vec4(1.0f - time, time, time, 1.0);// col;
		verts[idx + 1].color = outColor;
		verts[idx + 2].color = outColor;
		pt = t;
		px = x;
		py = y;
	}

//	verts[startIndex + 0].location = vec4(-0.05f + offsetX, -0.05f + offsetY, 0, 1.0);
//	verts[startIndex + 1].location = vec4(+0.05f + offsetX, -0.05f + offsetY, 0, 1.0);
//	verts[startIndex + 2].location = vec4(+0.00f + offsetX, +0.05f + offsetY, 0, 1.0);
											    
//	verts[startIndex + 0].color = vec4(1.0, 0.8, 0.3, 1.0);
//	verts[startIndex + 1].color = vec4(offsetX + 0.5, 0.1, 0.0, 1.0);
//	verts[startIndex + 2].color = vec4(0.1, 0.4, offsetY + 0.5, 1.0);
 }